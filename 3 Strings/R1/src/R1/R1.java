/*
 * Строки. Работа с регулярными выражениями. №1.

 *   Cоздать приложение, разбирающее текст (текст хранится в строке) и 
 * позволяющее выполнять с текстом три различных операции: отсортировать абзацы 
 * по количеству предложений; в каждом предложении отсортировать слова по длине;
 * отсортировать лексемы в предложении по убыванию количества вхождений 
 * заданного символа, а в случае равенства – по алфавиту.
 */

package R1;

import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.text.BadLocationException;

/**
 *
 * @author aabyodj
 */
public class R1 extends javax.swing.JFrame {

    /** Creates new form R1 */
    public R1() {
        initComponents();
        taskText = jTextArea1.getText(); //Текст условия задачи
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        exitButton = new javax.swing.JButton();
        actButton1 = new javax.swing.JButton();
        actButton2 = new javax.swing.JButton();
        actButton3 = new javax.swing.JButton();
        helpButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jSymbol = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("3. Строки - Регулярные выражения - Задача 1");
        setLocationByPlatform(true);

        exitButton.setText("Выход");
        exitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitButtonActionPerformed(evt);
            }
        });

        actButton1.setText("Абзацы");
        actButton1.setToolTipText("Отсортировать абзацы по количеству предложений");
        actButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                actButton1ActionPerformed(evt);
            }
        });

        actButton2.setText("Слова");
        actButton2.setToolTipText("В каждом предложении отсортировать слова по длине");
        actButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                actButton2ActionPerformed(evt);
            }
        });

        actButton3.setText("Символ");
        actButton3.setToolTipText("Отсортировать слова в предложениеях по количеству вхождений заданного символа, а при равенстве - по алфавиту");
        actButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                actButton3ActionPerformed(evt);
            }
        });

        helpButton1.setText("Задание");
        helpButton1.setToolTipText("Заполнить текстовое поле текстом задачи");
        helpButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                helpButton1ActionPerformed(evt);
            }
        });

        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jTextArea1.setText("Создать приложение, разбирающее текст (текст хранится в строке) и позволяющее выполнять с текстом три различных операции: \n* отсортировать абзацы по количеству предложений; \n* в каждом предложении отсортировать слова по длине; \n* отсортировать лексемы в предложении по убыванию количества вхождений заданного символа, а в случае равенства – по алфавиту.\n\n-----------------------------\n\nАбзац из трёх предложений, и это - первое из них. Это второе предложение. И, наконец, третье. \nВ этом абзаце два предложения. Предложение номер два.");
        jTextArea1.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextArea1);

        jSymbol.setColumns(1);
        jSymbol.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jSymbol.setText("а");
        jSymbol.setToolTipText("Символ, по количеству вхождений которого в слова производится сортировка");
        jSymbol.setMinimumSize(new java.awt.Dimension(15, 22));
        jSymbol.setPreferredSize(new java.awt.Dimension(15, 22));
        jSymbol.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jSymbolFocusGained(evt);
            }
        });
        jSymbol.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jSymbolActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(actButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(actButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(actButton3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSymbol, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 86, Short.MAX_VALUE)
                        .addComponent(helpButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(exitButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 245, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jSymbol, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(exitButton)
                        .addComponent(actButton1)
                        .addComponent(actButton2)
                        .addComponent(actButton3)
                        .addComponent(helpButton1)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitButtonActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitButtonActionPerformed

    /** Вывод условия задачи в текстовое поле */    
    private void helpButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpButton1ActionPerformed
        jTextArea1.setText(taskText);
    }//GEN-LAST:event_helpButton1ActionPerformed

    /** 
     *  Сортировка слов в каждом предложении по убыванию количества вхождений 
     * заданного символа, а в случае равенства - по алфавиту
     */
    private void actButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_actButton3ActionPerformed
        if (!jSymbol.getText().isBlank()) {
            jTextArea1.setText(sortBySymbol(jTextArea1.getText(),
                    jSymbol.getText().charAt(0)));
        } else {
        }
    }//GEN-LAST:event_actButton3ActionPerformed

    /** Сортировка абзацев по количеству предложений */
    private void actButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_actButton1ActionPerformed
        jTextArea1.setText(sortParagraphs(jTextArea1.getText()));
    }//GEN-LAST:event_actButton1ActionPerformed
    
    /** Сортировка слов в предложениях по длине */
    private void actButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_actButton2ActionPerformed
        jTextArea1.setText(sortByLength(jTextArea1.getText()));
    }//GEN-LAST:event_actButton2ActionPerformed

    private void jSymbolActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jSymbolActionPerformed
        String newSymbol = jSymbol.getText();
        if (!newSymbol.isBlank()) {
            newSymbol = newSymbol.substring(newSymbol.length() - 1);
            jSymbol.setText(newSymbol);
        }
        actButton3.doClick();
    }//GEN-LAST:event_jSymbolActionPerformed

    private void jSymbolFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jSymbolFocusGained
        jSymbol.setSelectionStart(0);
        jSymbol.setSelectionEnd(jSymbol.getText().length());
    }//GEN-LAST:event_jSymbolFocusGained

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(R1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(R1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(R1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(R1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new R1().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton actButton1;
    private javax.swing.JButton actButton2;
    private javax.swing.JButton actButton3;
    private javax.swing.JButton exitButton;
    private javax.swing.JButton helpButton1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jSymbol;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables

    
    String taskText; //Условие задачи
    static Pattern linesPattern = Pattern.compile("\\s*[\n\r]+"); //Разделение на абзацы
    static Pattern sntncPattern = Pattern.compile("[\\.\\!\\?]+"); //Разделение на предложения
    static Pattern wordsPattern = Pattern.compile("[\\s\\p{Punct}–-]+"); //Разделение на слова

    /** 
     *  Сортировка абзацев по количеству предложений
     * 
     * @param strIn исходный текст
     * @return отсортированный текст
     */     
    static String sortParagraphs(String strIn) {
        String[] paragraphs = linesPattern.split(strIn); //Разделение на абзацы
        IndexedValue[] sentCounts; //Подсчёт предложений в абзацах
        sentCounts = new IndexedValue[paragraphs.length];
        for (int i = 0; i < paragraphs.length; i++) {
            sentCounts[i] = new IndexedValue();
            sentCounts[i].index = i; 
            /* Критерий сортировки - количество предложений */
            sentCounts[i].value = sntncPattern.split(paragraphs[i]).length;
        }
        Arrays.sort(sentCounts);
        String result = ""; //Сборка текста с отсортированными абзацами
        for (var c: sentCounts) {
            result += paragraphs[c.index] + "\n";
        }
        return result;
    }

    /** 
     *  Сортировка слов в предложениях по длине
     * 
     * @param strIn
     * @return 
     */
    static String sortByLength(String strIn) {
        String[] paragraphs = linesPattern.split(strIn); //Разделение на абзацы
        String result = "";
        for (var par: paragraphs) {
            String[] sentences = sntncPattern.split(par);
            //Чтобы не потерять знак препинания в конце предложения
            Matcher pMatcher = sntncPattern.matcher(par);
            boolean firstSentence = true; //Пробел перед вторым и последующим предложениями
            for (var sentence : sentences) {
                String[] words = wordsPattern.split(sentence);
                if (words.length == 0) continue;
                if (firstSentence) {
                    firstSentence = false;
                } else {
                    result += " "; //Пробел перед вторым и последующим предложениями
                }
                IndexedValue[] sc; //Подсчёт символов в словах
                sc = new IndexedValue[words.length];
                for (int i = 0; i < words.length; i++) {
                    sc[i] = new IndexedValue();
                    sc[i].index = i;
                    sc[i].value = words[i].length();
                }
                Arrays.sort(sc);
                boolean firstWord = true;
                for (var c: sc) {
                    /* Предложение должно начинаться с заглавной буквы, при этом 
                    определение того, надо ли сделать строчной первую букву 
                    слова, которое ранее было первым, выходит далеко за рамки 
                    сложности этой задачи. */
                    if (firstWord) { 
                        if (c.value == 0) continue; //Пропуск слов с нулевой длиной
                        result += Character.toUpperCase(words[c.index].charAt(0));
                        result += words[c.index].substring(1);
                        firstWord = false;
                    } else { //Пробел между словами
                        result += " " + words[c.index];
                    }
                }
                if (pMatcher.find()) { //Знак препинания в конце предложения
                    result += par.substring(pMatcher.start(), pMatcher.end()); 
                } else {
                    result += "."; //Если ничего не было - ставим точку
                }
            }
            result += "\n";
        }
        return result;
    }
    
    /** 
     *  Сортировка слов в предложениях по убыванию количества вхождений 
     * заданного символа, а в случае равенства - по алфавиту
     * 
     * @param strIn исходный текст
     * @param symbol заданный символ
     * @return 
     */
    static String sortBySymbol(String strIn, char symbol) {
        String[] paragraphs = linesPattern.split(strIn); //Разделение на абзацы
        String result = "";
        for (var par: paragraphs) {
            String[] sentences = sntncPattern.split(par);
            //Чтобы не потерять знак препинания в конце предложения
            Matcher pMatcher = sntncPattern.matcher(par);
            boolean firstSentence = true; //Пробел перед вторым и последующим предложениями
            for (var sentence : sentences) {
                String[] words = wordsPattern.split(sentence);
                if (words.length == 0) continue;
                if (firstSentence) {
                    firstSentence = false;
                } else {
                    result += " "; //Пробел перед вторым и последующим предложениями
                }
                DoubleSort[] ds; //Подсчёт символов в словах
                ds = new DoubleSort[words.length];
                for (int i = 0; i < words.length; i++) {
                    ds[i] = new DoubleSort();
                    ds[i].word = words[i];
                    for (var ch: words[i].toCharArray()) { //Подсчёт вхождений заданного символа
                        if (ch == symbol) ds[i].value--;
                    }
                }
                Arrays.sort(ds);
                boolean firstWord = true;
                for (var c: ds) {
                    if (c.word.isBlank()) continue; //Пропуск пустых слов
                    /* Предложение должно начинаться с заглавной буквы, при этом 
                    определение того, надо ли сделать строчной первую букву 
                    слова, которое ранее было первым, выходит далеко за рамки 
                    сложности этой задачи. */
                    if (firstWord) { 
                        result += Character.toUpperCase(c.word.charAt(0));
                        result += c.word.substring(1);
                        firstWord = false;
                    } else { //Пробел между словами
                        result += " " + c.word;
                    }
                }
                if (pMatcher.find()) { //Знак препинания в конце предложения
                    result += par.substring(pMatcher.start(), pMatcher.end()); 
                } else {
                    result += "."; //Если ничего не было - ставим точку
                }
            }
            result += "\n";
        }
        return result;
    }
}

/**
 *  Элемент массива для сортировки сущностей по заданным признакам посредством 
 * Arrays.sort()
 * @author aabyodj
 */
class IndexedValue implements Comparable <IndexedValue> {
    /** Индекс сущности в связанном массиве */
    public int index;
    /** Признак, по которому производится сортировка */
    public int value;
    
    @Override
    public int compareTo (IndexedValue that) {
        return this.value - that.value;
    }
}

/**
 *  Элемент массива для сортировки слов посредством Arrays.sort() по заданному 
 * признаку, а в случае равенства - по алфавиту
 * @author aabyodj
 */
class DoubleSort implements Comparable <DoubleSort> {
    
    /** Основной признак, по которому производится сортировка */
    public int value;
    
    /** 
     *  Слово. В случае равенства первичных признаков value происходит 
     * сортировка слов по алфавиту.
     */
    public String word;
    
    @Override
    public int compareTo (DoubleSort that) {
        if (this.value == that.value) {
            return this.word.compareToIgnoreCase(that.word);
        } else {            
            return this.value - that.value;
        }
    }
}